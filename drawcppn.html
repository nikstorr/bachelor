<!DOCTYPE html>
<html>
  <head>
      <title>breedesizer // audiovolve</title>

      <script src="bower_components/jquery/dist/jquery.min.js"></script>
      <script src="bower_components/jquery-ui/jquery-ui.min.js"></script>
      <script src="lib/neat-build.js"></script>
      <script src="lib/dygraph-combined.js"></script>
  </head>
  <body>

    <p>CPPN JSON:</p>
    <textarea rows="4" cols="50" id="cppnjson">

    </textarea>

    <input type="button" id="draw" value="Draw!" />

    <br /><br />

    <div id="graph"></div>

    <script type="text/javascript">

      var neatjs = require('neatjs');

      var cppnjs = require('optimuslime~cppnjs@master');


      ////////////////////
      // Szerlip: Adjust activation functions inside of CPPNs

      var actFunctions = cppnjs.cppnActivationFunctions;
      var actFactory = cppnjs.cppnActivationFactory;

      var waveActivationFunction = {sin: "sin", cos: "cos", arctan: "arctan"}

      actFunctions[waveActivationFunction.sin] = function(){
         return new actFunctions.ActivationFunction({
              functionID: waveActivationFunction.sin,
              functionString: "sin(inputSignal)",
              functionDescription: "sin function with normal period",
              functionCalculate: function(inputSignal)
              {
                  return Math.sin(inputSignal);
              },
              functionEnclose: function(stringToEnclose)
              {
                  return "(Math.sin(" + stringToEnclose + "))";
              }
          });
      };

      actFunctions[waveActivationFunction.cos] = function(){
         return new actFunctions.ActivationFunction({
              functionID: waveActivationFunction.cos,
              functionString: "Cos(inputSignal)",
              functionDescription: "Cos function with normal period",
              functionCalculate: function(inputSignal)
              {
                  return Math.cos(inputSignal);
              },
              functionEnclose: function(stringToEnclose)
              {
                  return "(Math.cos(" + stringToEnclose + "))";
              }
          });
      };


      actFunctions[waveActivationFunction.arctan] = function(){
          return new actFunctions.ActivationFunction({
              functionID: waveActivationFunction.arctan,
              functionString: "atan(inputSignal)",
              functionDescription:"Arc Tan with normal period",
              functionCalculate: function(inputSignal)
              {
                  return Math.atan(inputSignal);
              },
              functionEnclose: function(stringToEnclose)
              {
                  return "(Math.atan(" + stringToEnclose + "))";
              }
          });
      };

      //makes these the only activation functions being generated by wave genotypes -- all equal probabilibty for now
      var probs = {};
      probs[waveActivationFunction.sin] = .33;
      probs[waveActivationFunction.cos] = .33;
      probs[waveActivationFunction.arctan] = .33;
      actFactory.setProbabilities(probs);



      ////////////////////
      // Parse and draw CPPNs

      $('#draw').click(function(){

        var parsedGenome = JSON.parse( $('#cppnjson').val() );

        var neatGenome = new neatjs.neatGenome(
          parsedGenome.offspring.gid,
          parsedGenome.offspring.nodes,
          parsedGenome.offspring.connections,
          parsedGenome.offspring.inputNodeCount,
          parsedGenome.offspring.outputNodeCount,
          parsedGenome.offspring.debug
        );

        var cppn = neatGenome.networkDecode();

        // let's activate the cppn for each sample
        var fourierTransformTableSize = 1024;
        var inputPeriods = 10;
        var outputs = [];
        for( var j=0; j < fourierTransformTableSize; j++ ) {

          var rangeFraction = j / (fourierTransformTableSize-1);

          var yInputSignal = lerp( -1, 1, rangeFraction );

          var extraInput = Math.sin( inputPeriods * Math.abs(yInputSignal) );

          var inputSignals = [extraInput, Math.abs(yInputSignal)]; // d(istance), input


          cppn.clearSignals();
          cppn.setInputSignals( inputSignals );
          cppn.recursiveActivation();

          outputs.push(
            [j, cppn.getOutputSignal(0), cppn.getOutputSignal(1)] );
        }

        new Dygraph(
          document.getElementById("graph"),
          outputs,
          {
            labels: ["time (frequency) domain", "modulation", "carrier" ],
            valueRange: [-1, 1]
          }
        );
      });



      function lerp( from, to, fraction ) {
        return from + fraction * ( to - from );
      }

    </script>
  </body>
</html>
