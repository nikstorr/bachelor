var neatjs = require('neatjs');
var cppnjs = require('optimuslime~cppnjs@master');

window.AudioContext = window.AudioContext || window.webkitAudioContext;
var audioContext = new AudioContext();

//////////////////////////////////////////////////////
//guitar
var live = true; // no live guitar input, use sampled data instead
var audioData = null;
var audioBuffer;
var source, source2; // sound source
var request;
var processor;
var buff = audioContext.createBuffer(2, audioContext.sampleRate *2.0, audioContext.sampleRate);
var effectGain = 50;      // Initial amount of effect
var distortionGain = 100; // Initial amount of distortion
var cleanSoundAmount = 2;
var channels = 2;

var analyser = audioContext.createAnalyser();

// A bit of colors
var distortion = audioContext.createWaveShaper();
var compressor = audioContext.createDynamicsCompressor();
var convolver = audioContext.createConvolver();

var debug = false;

//////////////////////////////////////////////////////
// meter
var audioBuffer;
var splitter;
var analyser2;
var javascriptNode;

// get the context from the canvas to draw on
var ctx = $("#meter").get()[0].getContext("2d");
ctx.rotate(9*Math.PI/180);

// create a gradient for the fill. Note the strange
// offset, since the gradient is calculated based on
// the canvas, not the specific element we draw
var gradient = ctx.createLinearGradient(0,0,0,130);
gradient.addColorStop(1,'#000000');
gradient.addColorStop(0.75,'#ff0000');
gradient.addColorStop(0.25,'#ffff00');
gradient.addColorStop(0,'#ffffff');

javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
// connect to destination, else it isn't called
javascriptNode.connect(audioContext.destination);

analyser.smoothingTimeConstant = 0.3;
analyser.fftSize = 1024;

analyser2 = audioContext.createAnalyser();
analyser2.smoothingTimeConstant = 0.0;
analyser2.fftSize = 1024;

splitter = audioContext.createChannelSplitter();

////////////////////////////////////
// frewquency spectrum
// get the context from the canvas to draw on
var ctx2 = $("#canvas").get()[0].getContext("2d");



///////////////////////////////////////////////////////
// Szerlip: Adjust activation functions inside of CPPNs

var actFunctions = cppnjs.cppnActivationFunctions;
var actFactory = cppnjs.cppnActivationFactory;

var waveActivationFunction = {
  sin: "sin", cos: "cos", arctan: "arctan",
  spike: "spike"
}

actFunctions[waveActivationFunction.spike] = function(){
  return new actFunctions.ActivationFunction({
    functionID: waveActivationFunction.spike,
    functionString: "if(floor(x) is even) 1 - 2*(x-floor(x)) else -1 + 2*(x-floor(x))",
    functionDescription: "Basically a pointy version of sin or cos.",
    functionCalculate: function(inputSignal)
    {
        if(Math.floor(inputSignal)%2 == 0) return 1.0 - 2.0 * (inputSignal-Math.floor(inputSignal));
        else return -1.0 + 2.0 * (inputSignal-Math.floor(inputSignal));
    },
    functionEnclose: function(stringToEnclose)
    {
        return "if(Math.floor("+stringToEnclose+")%2 == 0) return 1.0 - 2.0 * ("+stringToEnclose+"-Math.floor("+stringToEnclose+"));"
        +"else return -1.0 + 2.0 * ("+stringToEnclose+"-Math.floor("+stringToEnclose+"));";
    }
  });
};

actFunctions[waveActivationFunction.sin] = function(){
   return new actFunctions.ActivationFunction(
     {
        functionID: waveActivationFunction.sin,
        functionString: "sin(inputSignal)",
        functionDescription: "sin function with normal period",
        functionCalculate: function(inputSignal)
        {
            return Math.sin(inputSignal);
        },
        functionEnclose: function(stringToEnclose)
        {
            return "(Math.sin(" + stringToEnclose + "))";
        }
    }

    );
};

actFunctions[waveActivationFunction.cos] = function(){
   return new actFunctions.ActivationFunction({
        functionID: waveActivationFunction.cos,
        functionString: "Cos(inputSignal)",
        functionDescription: "Cos function with normal period",
        functionCalculate: function(inputSignal)
        {
            return Math.cos(inputSignal);
        },
        functionEnclose: function(stringToEnclose)
        {
            return "(Math.cos(" + stringToEnclose + "))";
        }
    });
};


actFunctions[waveActivationFunction.arctan] = function(){
    return new actFunctions.ActivationFunction({
        functionID: waveActivationFunction.arctan,
        functionString: "atan(inputSignal)",
        functionDescription:"Arc Tan with normal period",
        functionCalculate: function(inputSignal)
        {
            return Math.atan(inputSignal);
        },
        functionEnclose: function(stringToEnclose)
        {
            return "(Math.atan(" + stringToEnclose + "))";
        }
    });
};

//makes these the only activation functions being generated by wave genotypes -- all equal probabilibty for now
var probs = {};
probs[waveActivationFunction.sin] = .25;
probs[waveActivationFunction.cos] = .25;
probs[waveActivationFunction.arctan] = .25;
probs[waveActivationFunction.spike] = .25;
actFactory.setProbabilities(probs);

///////////////////////////////////////////////////
// seed creation

var weightRange = 2;
var connectionProportion = 1;  //  1
var ins = 2;
var outs = 2;

var seedCount = 5;
var initialPopulationSeeds = [];
// create initial seed genomes for coming population(s members)
for( var i=0; i < seedCount; i++ ) {

  //clear out genome IDs and innovation IDs
  // -> not sure why / if this is needed?
  neatjs.neatGenome.Help.resetGenomeID();
  // NeatGenome.Help.resetInnovationID();

  var neatGenome = neatjs.neatGenome.Help.CreateGenomeByInnovation(
            ins,
            outs,
            {
              connectionProportion: connectionProportion,
              connectionWeightRange: weightRange
            }
  );
  initialPopulationSeeds.push( neatGenome );
}

// console.log( initialPopulationSeeds );


///////////////////////////////////////////////////
// Interactive Evolution Computation (IEC) setup

var np = new neatjs.neatParameters();
// defaults taken from
// https://github.com/OptimusLime/win-gen/blob/d11e6df5e7b8948f292c999ad5e6c24ab0198e23/old/plugins/NEAT/neatPlugin.js#L63
// https://github.com/OptimusLime/win-neat/blob/209f00f726457bcb7cd63ccc1ec3b33dec8bbb66/lib/win-neat.js#L20
np.pMutateAddConnection = .13;       // .13
np.pMutateAddNode = .13;             // .13
np.pMutateDeleteSimpleNeuron = .00;  // .00
np.pMutateDeleteConnection = .00;
np.pMutateConnectionWeights = .72;
np.pMutateChangeActivations = .07;

np.pNodeMutateActivationRate = 0.2;
np.connectionWeightRange = 3.0;
np.disallowRecurrence = true;


// IEC options taken from
// https://github.com/OptimusLime/win-Picbreeder/blob/33366ef1d8bfd13c936313d2fdb2afed66c31309/html/pbHome.html#L95
// https://github.com/OptimusLime/win-Picbreeder/blob/33366ef1d8bfd13c936313d2fdb2afed66c31309/html/pbIEC.html#L87
var iecOptions = {
  initialMutationCount : 5,
  postMutationCount : 5  // AKA mutationsOnCreation
};

var iecGenerator = new neatjs.iec( np, initialPopulationSeeds, iecOptions );


///////////////////////////////////////////////////
// Create first population from seeds
var currentPopulationIndex = 0;
var currentPopulationMemberOutputs = undefined; // to be an array populated in renderPopulation

var populations = [];
var populationSize = 10;

var fourierTransformTableSize = 1024;
var currentIndividualPeriodicWaves = undefined; // to be an object literal

createFirstPopulation();
displayCurrentGeneration();
renderPopulation( currentPopulationIndex );

// let's decrease the mutation count after creating the first population
iecOptions.initialMutationCount = 1;  // 1
iecOptions.postMutationCount = 1;
//$( "#slider-initialMutationCount" ).slider( "value", iecOptions.initialMutationCount );
//$( "#slider-postMutationCount" ).slider( "value", iecOptions.postMutationCount );

function createFirstPopulation() {

  var firstPopulation = [];
  for( var i=0; i < populationSize; i++ ) {

    // individuals in the first population have no actual parents;
    // instead they are mutations of some random seed genome:
    var onePopulationMember = iecGenerator.createNextGenome( [] );
    firstPopulation.push( onePopulationMember );
  }

  populations.push( firstPopulation );
}

var inputPeriods = 10;
var variationOnPeriods = false;

/// <summary>
/// Render waveforms.
/// </summary>
/// <param name="populationIndex">an index into array 'population' (holding generations of ten genomes).</param>
function renderPopulation( populationIndex ) {
  /* */
  currentPopulationMemberOutputs = [];

  var populationToRender = populations[populationIndex];

  // console.log( "fourierTransformTableSize: " + fourierTransformTableSize);

  /* for each member in the population*/
  for( var i=0; i < populationToRender.length; i++ ) {
    var oneMember = populationToRender[i];
    /* a CPPN. info about nodecount, input neurons, output neurons, biaslist, activationfunction etc. */
    var oneMemberCPPN = oneMember.offspring.networkDecode();
    // console.log( "connections: " + oneMemberCPPN.connections.length + ", neurons: " + oneMemberCPPN.totalNeuronCount );

    /* */
    var oneMemberOutputs = [];
    for( var j=0; j < fourierTransformTableSize; j++ ) {
      var rangeFraction = j / (fourierTransformTableSize-1);
      var yInputSignal = lerp( -1, 1, rangeFraction );
      if( variationOnPeriods ) {
        var extraInput = Math.sin( inputPeriods * yInputSignal );
      } else {
        var extraInput = Math.sin( inputPeriods * Math.abs(yInputSignal) );
      }
      var inputSignals = [extraInput, Math.abs(yInputSignal)]; // d(istance), input

      oneMemberCPPN.clearSignals();
      oneMemberCPPN.setInputSignals( inputSignals );

      oneMemberCPPN.recursiveActivation();

      oneMemberOutputs.push(
        [j, oneMemberCPPN.getOutputSignal(0), oneMemberCPPN.getOutputSignal(1)] );
    }

    currentPopulationMemberOutputs.push( oneMemberOutputs );

    new Dygraph(
      document.getElementById("graph-"+i),
      oneMemberOutputs,
      {
        labels: ["time (frequency?) domain", "modulation", "carrier" ],
        valueRange: [-1, 1]
      }
    );
  }
}

var modulationWave = [];
var carrierWave = [];

function getPeriodicWavesForMemberInCurrentPopulation( memberIndex ) {
  //
  var cppnOutputs = currentPopulationMemberOutputs[ memberIndex ];

  modulationWave = [];
  carrierWave = [];

  /* */
  cppnOutputs.forEach(function(oneOutputSet, index, array){
    modulationWave.push( oneOutputSet[1] );
    carrierWave.push( oneOutputSet[2] );
  });

  // Fourier transform
  var ftModulator = new DFT( modulationWave.length );
  ftModulator.forward( modulationWave );
  var ftCarrier = new DFT( carrierWave.length );
  ftCarrier.forward( carrierWave );

  var modulatorWaveTable = audioContext.createPeriodicWave(
    ftModulator.real, ftModulator.imag
  );

  var carrierWaveTable = audioContext.createPeriodicWave(
    ftCarrier.real, ftCarrier.imag
  );

  return {
      'modulator': modulatorWaveTable,
      'carrier': carrierWaveTable
  };
}

function evolveNextGeneration() {

  // let's get all user selected individuals in the UI, to use as parents
  var parentIndexes = [];
  $( "input[name^='member-']:checked" ).each(function(){
    parentIndexes.push( parseInt( $(this).attr("name").substring(7) ) );
  });
  // and if there are no individuals selected in the UI
  if( parentIndexes.length < 1 ) {
    // let's check if some waveform is seleced for playing
    // and then use that as a parent
    if( currentMemberIndex !== undefined ) {
      parentIndexes.push( currentMemberIndex );
    } else {
      alert("At least one parent needs to be selected for the next generation.");
      return;
    }
  }

  var currentPopulation = populations[currentPopulationIndex];
  var parents = [];
  /* gather selected individuals' children for breeding the next generation */
  $.each( parentIndexes, function( oneParentIndex, value ) {
    parents.push( currentPopulation[oneParentIndex].offspring );
  });

  // parents of the new generation
  console.log( parents );

  // let's create a new population from the chosen parents
  var newPopulation = [];
  for( var i=0; i < populationSize; i++ ) {
    var onePopulationMember = iecGenerator.createNextGenome( parents );
    newPopulation.push( onePopulationMember );
  }
  // increase the # generations
  currentPopulationIndex++;
  populations.push( newPopulation );

  /* prints 'generation1' or 'generation2' etc.*/
  displayCurrentGeneration();
  renderPopulation( currentPopulationIndex );

  /* de-select checkboxes*/
  $( "input[name^='member-']" ).each( function(){
    $(this).attr( 'checked', false );
  });
  /* reset background color*/
  $( ".member-container" ).each( function(){
    $(this).find("div:first").css( {"background-color": "#fff"} );
  });

  /* de-select waveform */
  currentIndividualPeriodicWaves = undefined;

  $("#back").show();
}

function backOneGeneration() {
  if( currentPopulationIndex > 0 ) {

    populations.pop();
    currentPopulationIndex--;

    $( ".member-container" ).each( function(){
      $(this).find("div:first").css( {"background-color": "#fff"} );
    });

    displayCurrentGeneration();
    renderPopulation( currentPopulationIndex );
  }
}



///////////////////////////////////////////////////
// CPPN printing and saving

function getCurrentCPPNAsString() {
  return JSON.stringify(
      populations[currentPopulationIndex][currentMemberIndex],
      null,
      '\t'
    );
}

function printCurrentCPPNtoString() {
  $("#printCPPN").text( getCurrentCPPNAsString() );
}

function saveCurrentCPPNToFile( filename ) {
  var blob = new Blob([getCurrentCPPNAsString()], {type: "application/json"});

  // following based on https://github.com/mattdiamond/Recorderjs/blob/master/recorder.js#L77
  var url = (window.URL || window.webkitURL).createObjectURL(blob);
  var link = window.document.createElement('a');
  link.href = url;
  link.download = filename || 'output.txt';
  var click = document.createEvent("Event");
  click.initEvent("click", true, true);
  link.dispatchEvent(click);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////
// interface event handling //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

/* currently selected waveform (for playing) */
var currentMemberIndex = undefined;

/* click handler , all-in-one */
$(function() {
  var selectedMembersIndexes = [];

  $(".evolve").click( function() {
    evolveNextGeneration();
  });

  $("#back").click( function() {
    backOneGeneration();
  });

  $("#back").hide();

  /* when a 'sound' is selected ...  */
  $(".member-container div").click( function() {
      var $this = $(this);

      /* ... we de-select all other 'sounds'*/
      selectedMembersIndexes.forEach(function(memberIdx, index, array){
        var $oneMemberContainer = $("#member-container-"+memberIdx);
        $oneMemberContainer.find("div:first").css( {"background-color": "#FFF"} );
/*
        // let's deselect all members other than the one clicked for now
        $oneMemberContainer.find("#member-"+memberIdx).attr( "checked", false );
*/
      });

      selectedMembersIndexes = [];

      /* ... and print 'computing' into its span tag for 100 millisecs */
      $this.parent().find("span.computing-message").show( 100, function(){
        /* ... waveform id*/
        currentMemberIndex = parseInt( $this.parent().attr("id").substring(17) );

        /* ... currently selected waveform */
        currentIndividualPeriodicWaves =
          getPeriodicWavesForMemberInCurrentPopulation( currentMemberIndex );

        /* ... collect this 'sound' id (for parenting next generation) */
        selectedMembersIndexes.push( currentMemberIndex );
        /* ... hide its span again*/
        $this.parent().find("span.computing-message").hide();
        /* ... highlight background hideously yellow'ish */
        $this.css( {"background-color": "#CCC"} );
        /* ... play sound */
        playSelectedWaveformsForOneQuarterNoteC3();
        /* ... print child node CPPN mumbo-jumbo*/
        printCurrentCPPNtoString();

      });
  });

  /* ... */
  $("#recordSample").click( function(){
    if( currentIndividualPeriodicWaves ) {
      playSelectedWaveformsForOneQuarterNoteC3( true );
    } else {
      alert("Please select a waveform first");
    }
  });

  $("#stopRecordSample").click( function(){
    if( currentIndividualPeriodicWaves ) {
      stopRecordingAndSave();
    } else {
      alert("Please select a waveform first");
    }
  });



  /*
  shouldModulate = $("#modulate")[0].checked;
  $("#modulate").click( function() {
    shouldModulate = $(this)[0].checked;
  });

  useEnvelope = $("#envelope")[0].checked;
  $("#envelope").click( function() {
    useEnvelope = $(this)[0].checked;
  });

*/

  variationOnPeriods = $("#variation")[0].checked;
  $("#variation").click( function(){
    variationOnPeriods = $(this)[0].checked;

    renderPopulation( currentPopulationIndex );
    if( currentMemberIndex !== undefined ) {
      currentIndividualPeriodicWaves =
        getPeriodicWavesForMemberInCurrentPopulation( currentMemberIndex );

      playSelectedWaveformsForOneQuarterNoteC3();
    }
  });


  // sliders

  var commonPercentageSliderOptions = {
    orientation: "horizontal",
    range: "min",
    max: 100,
    value: 0
  };

  $( "#slider-effect").slider(
    $.extend({
      slide: updateEffectAmount,
      change: updateEffectAmount
    }, commonPercentageSliderOptions )
  );

  $( "#slider-distortion").slider(
    $.extend({
      slide: updateDistortionAmount,
      change: updateDistortionAmount
    }, commonPercentageSliderOptions )
  );


  $( "#slider-pMutateAddConnection").slider(
    $.extend({
      slide: updateMutateAddConnectionP,
      change: updateMutateAddConnectionP
    }, commonPercentageSliderOptions )
  );
  $( "#slider-pMutateAddNode").slider(
    $.extend({
      slide: updateMutateAddNodeP,
      change: updateMutateAddNodeP
    }, commonPercentageSliderOptions )
  );
  $( "#slider-pMutateAddConnection" ).slider( "value", np.pMutateAddConnection * 100 );
  $( "#slider-pMutateAddNode" ).slider( "value", np.pMutateAddNode * 100 );


  var commonMutationCountSliderOptions = {
    orientation: "horizontal",
    range: "min",
    max: 5,
    value: 0
  };
  $( "#slider-initialMutationCount" ).slider(
    $.extend({
      slide: updateInitialMutationCount,
      change: updateInitialMutationCount
    }, commonMutationCountSliderOptions )
  );
  $( "#slider-postMutationCount" ).slider(
    $.extend({
      slide: updatePostMutationCount,
      change: updatePostMutationCount
    }, commonMutationCountSliderOptions )
  );
  $( "#slider-initialMutationCount" ).slider( "value", iecOptions.initialMutationCount );
  $( "#slider-postMutationCount" ).slider( "value", iecOptions.postMutationCount );

  $( "#slider-ftSize" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 4096,
    min: 32,
    value: fourierTransformTableSize,
    slide: updateFTsize,
    change: updateFTsize
  });
  $( "#slider-ftSize" ).slider( "value", fourierTransformTableSize );

  $( "#slider-repetition" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 50,
    min: 1,
    value: inputPeriods,
    slide: renderNewRepetition,
    change: renderNewRepetition
  });
  $( "#slider-repetition" ).slider( "value", inputPeriods );

  $( "#slider-modulatorgain" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 600,
    min: 1,
    value: modulatorGain,
    slide: updateModulatorGain,
    change: updateModulatorGain
  });
  $( "#slider-modulatorgain" ).slider( "value", modulatorGain );

  $( "#slider-modulatordetune" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 100,
    min: -100,
    value: modulatorDetune,
    slide: updateModulatorDetune,
    change: updateModulatorDetune
  });
  $( "#slider-modulatordetune" ).slider( "value", modulatorDetune );

  $( "#slider-modulatorquarter" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 48,
    min: -4,
    value: modulatorQuarterOctaveOffset,
    slide: updateModulatorQuarterOctaveOffset,
    change: updateModulatorQuarterOctaveOffset
  });
  $( "#slider-modulatorquarter" ).slider( "value", modulatorQuarterOctaveOffset );

  $( "#slider-effect" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 100,
    min: 0,
    value: effectGain,
    slide: updateEffectAmount,
    change: updateEffectAmount
  });
  $( "#slider-effect" ).slider( "value", effectGain );

  $( "#slider-distortion" ).slider({
    orientation: "horizontal",
    range: "min",
    max: 500,
    min: 0,
    value: distortionGain,
    slide: updateDistortionAmount,
    change: updateDistortionAmount
  });
  $( "#slider-distortion" ).slider( "value", distortionGain );


});


///////////////////////////////////////////////////
// sliders

function updateEffectAmount(){
  effectGain = $( "#slider-effect" ).slider( "value" );
  $( "#amount-effect" ).val( effectGain );


}
function updateDistortionAmount(){
  //console.log("updating distortion");
  distortionGain = $( "#slider-distortion" ).slider( "value" );
  $( "#amount-distortion" ).val( distortionGain );



  distortion.curve = makeDistortionCurve(distortionGain);
}




function updateMutateAddConnectionP() {
  np.pMutateAddConnection = $( "#slider-pMutateAddConnection" ).slider( "value" ) / 100;
  iecGenerator.np.pMutateAddConnection = np.pMutateAddConnection;
  $( "#amount-pMutateAddConnection" ).val( np.pMutateAddConnection );
}
function updateMutateAddNodeP() {
  np.pMutateAddNode = $( "#slider-pMutateAddNode" ).slider( "value" ) / 100;
  iecGenerator.np.pMutateAddNode = np.pMutateAddNode;
  $( "#amount-pMutateAddNode" ).val( np.pMutateAddNode );
}

function updateInitialMutationCount() {
  iecOptions.initialMutationCount = $( "#slider-initialMutationCount" ).slider( "value" );
  iecGenerator.options.initialMutationCount = iecOptions.initialMutationCount;
  $( "#amount-initialMutationCount" ).val( iecOptions.initialMutationCount );
}
function updatePostMutationCount() {
  iecOptions.postMutationCount = $( "#slider-postMutationCount" ).slider( "value" );
  iecGenerator.options.postMutationCount = iecOptions.postMutationCount;
  $( "#amount-postMutationCount" ).val( iecOptions.postMutationCount );
}

function updateFTsize() {
  fourierTransformTableSize = $( "#slider-ftSize" ).slider( "value" );
  $( "#amount-ftSize" ).val( fourierTransformTableSize );
}

function renderNewRepetition() {
  inputPeriods = $( "#slider-repetition" ).slider( "value" );
  if( populations[currentPopulationIndex].length > 0 ) {

    renderPopulation( currentPopulationIndex );
  }
  if( currentMemberIndex !== undefined ) {
    currentIndividualPeriodicWaves =
      getPeriodicWavesForMemberInCurrentPopulation( currentMemberIndex );

      if( inputPeriods != $( "#amount-repetition" ).val() ) {

        playSelectedWaveformsForOneQuarterNoteC3();
      }
  }
  $( "#amount-repetition" ).val( inputPeriods );
}

function updateModulatorGain() {
  modulatorGain = $( "#slider-modulatorgain" ).slider( "value" );

  // if( currentMemberIndex !== undefined && modulatorGain != $( "#amount-modulatorgain" ).val() ) {
  //   playSelectedWaveformsForOneQuarterNoteC3();
  // }

  $( "#amount-modulatorgain" ).val( modulatorGain );
}

function updateModulatorDetune() {
  modulatorDetune = $( "#slider-modulatordetune" ).slider( "value" );

  // if( currentMemberIndex !== undefined && modulatorDetune != $( "#amount-modulatordetune" ).val() ) {
  //   playSelectedWaveformsForOneQuarterNoteC3();
  // }

  $( "#amount-modulatordetune" ).val( modulatorDetune );
}

function updateModulatorQuarterOctaveOffset() {
  modulatorQuarterOctaveOffset = $( "#slider-modulatorquarter" ).slider( "value" );

  // if( currentMemberIndex !== undefined && modulatorQuarterOctaveOffset != $( "#amount-modulatorquarter" ).val() ) {
  //   playSelectedWaveformsForOneQuarterNoteC3();
  // }

  $( "#amount-modulatorquarter" ).val( modulatorQuarterOctaveOffset );
}



var shouldModulate;
var modulatorGain = 300;
var modulatorDetune = 0;
var modulatorQuarterOctaveOffset = 0;

///////////////////////////////////////////////////
// oscillators
// ( object setup inspired by http://greweb.me/2013/08/FM-audio-api/ )

// envelopes from http://jsfiddle.net/greweb/tyEKr/8/
function noteOn( freq, time ) {
  carrier.noteOn(freq, time);
  modulator.noteOn(freq, time);
}

function noteOff( time ) {
  carrier.noteOff(time);
  modulator.noteOff(time);
}

function envelope( gainNode, time, volume, attackDuration, decayDuration, sustain ) {
  gainNode.gain.cancelScheduledValues(time);
  gainNode.gain.value = volume;
  gainNode.gain.setValueAtTime(0, time);
  gainNode.gain.linearRampToValueAtTime(volume, time + attackDuration);
  gainNode.gain.linearRampToValueAtTime(volume * sustain, time + attackDuration + decayDuration);
}

function envelopeRelease( gainNode, time, releaseTime ) {
  gainNode.gain.cancelScheduledValues(0);
  //gainNode.gain.setValueAtTime(gainNode.gain.value, time);
  gainNode.gain.linearRampToValueAtTime(0, time + releaseTime);
}


// A modulator with an oscillator and gain
function Modulator( /*frequency, gain, detune */) {

}
Modulator.prototype = {
  noteOn: function( /*freq, time*/ ) {
    //envelope( this.gain, time, freq, this.attackDuration, this.decayDuration, this.sustain );

  },
  noteOff: function( /*time*/ ) {
    //envelopeRelease( this.gain, time, this.releaseTime );
  }
}
// distortion
function makeDistortionCurve(amount) {
  // console.log(amount);
  var k = typeof amount === 'number' ? amount : 50,
  n_samples = 44100,
  curve = new Float32Array(n_samples),
  deg = Math.PI / 180,
  i = 0,
  x;
  for ( ; i < n_samples; ++i ) {
    x = i * 2 / n_samples - 1;
    curve[i] = ( 3 + k ) * x * 50 * deg / ( Math.PI + k * Math.abs(x) );
  }
  return curve;
};
// compressor
function comp(){
  compressor.threshold.value = -50;
  compressor.knee.value = 40;
  compressor.ratio.value = 8;
  compressor.reduction.value = -20;
  compressor.attack.value = 0.5;
  compressor.release.value = 0.25;
}

function Carrier(  ) {
  this.noteOff();
  console.log("carrier");
  // load sampled audio
  if(live == false){
    this.load();
  }

  this.gain = audioContext.createGain();
  var convolverBuffer;

  //////////////////////////////////////////////////
  // 'mate' the guitar samples with CPPNs
  processor = audioContext.createScriptProcessor(fourierTransformTableSize, 1, 1);
  processor.onaudioprocess = function(event){
    // guitar
    var inputBuff = event.inputBuffer;
    // TRY a convolver
    // convolverBuffer = audioContext.createBuffer(2, 0.5 * inputBuff.length, audioContext.sampleRate);

    // samples to be manipulated
    var outputBuff = event.outputBuffer;
    // Loop through the output channels
    for (var channel = 0; channel < outputBuff.numberOfChannels; channel++) {
      var inputData = inputBuff.getChannelData(channel);
      var outputData = outputBuff.getChannelData(channel);

      //var chnDta = convolverBuffer.getChannelData[channel];

      // Loop through the samples
      for (var sample = 0; sample < inputBuff.length; sample++) {
        // make output equal to the same as the input
        outputData[sample] = inputData[sample];  //
        //chnDta[sample] = Math.random() *2 -1;

        var eff = Math.sin(0.0);

        eff += ( carrierWave[sample] * modulationWave[sample]) / 6;

        var cppn = ( carrierWave[sample] + modulationWave[sample] ) * (effectGain/100);



        // amplitude modulation effect
        outputData[sample] *=  cppn ;// add neurons here
        outputData[sample] += inputData[sample]/cleanSoundAmount;

      }
    }
  }

  /* Not when live input
  ///////////////////////////////////////////////
  source.onended = function(){
    console.log("end");
    source.disconnect(processor);
    processor.disconnect(audioContext.destination);
  }*/

  /////////////////////////////
  // hook up effects

  // build a compressor
  comp();

  source.connect(analyser);
  analyser.connect(this.gain);
  this.gain.connect(processor);
  this.gain.gain.value = 1.0;

  // build a distortion
  processor.connect(distortion);
  distortion.curve = makeDistortionCurve(distortionGain);
  distortion.oversample = '4x';

  distortion.connect(compressor);

//    convolver.buffer = convolverBuffer;
//    compressor.connect(convolver);

  compressor.connect(audioContext.destination);

  //////////////////////////////
  // meter

  // connect the source to the analyser and the splitter
  source.connect(splitter);

  // connect one of the outputs from the splitter to
  // the analyser
  splitter.connect(analyser,0,0);
  splitter.connect(analyser2,1,0);
  analyser.connect(javascriptNode);
}
Carrier.prototype = {
  noteOn: function( time ) {
    source.connect(processor);
    processor.connect(audioContext.destination);
    //if(live == false){
    //source.start(0);
    // }
  },
  noteOff: function( time ) {
    if(processor){
      source.disconnect(processor);
      processor.disconnect(audioContext.destination);
    }
  }, // load audio
  load: function(){
    source = audioContext.createBufferSource();
    if(live == false){
      request = new XMLHttpRequest();
      request.open('GET', 'Audio2.wav', true);
      request.responseType = 'arraybuffer';
      request.onload = function() {
        audioContext.decodeAudioData(request.response, function(data) {
            source.buffer = data;
          },
          function(e){"Error with decoding audio data" + e.err});
      }
      request.send();
    }

  }
}
//////////////////////////////////////////////
// Default action. Access to the microphone.
// If a guitar is plugged in, that will be the input.
window.onload = function(){
  navigator.getUserMedia = ( navigator.getUserMedia ||
                         navigator.webkitGetUserMedia ||
                         navigator.mozGetUserMedia ||
                         navigator.msGetUserMedia);

  if (navigator.getUserMedia) {
    navigator.getUserMedia ({audio:true}, success,  error );
  } else {
     console.log("getUserMedia not supported");
  }
}

function error(err) {
  console.log("The following error occured: " + this.err);
}

// set guitar/microphone stream as input
function success(stream) {
  console.log("stream");
  // an input source
  source = audioContext.createMediaStreamSource(stream);
}


function createAndPlayModulatorsForFrequency( frequency, initialGain ) {

  var carrier = new Carrier(  );
  var modulator = undefined;

  if( shouldModulate ) {

    modulator = new Modulator(  );
  //  modulator.gain.connect( carrier.oscillator.frequency );
  }

  carrier.gain.gain.value = initialGain;
  carrier.gain.connect( masterGain );

  return {
    "carrier": carrier,
    "modulator": modulator
  };
}

function playSelectedWaveformsForOneQuarterNoteC3( recordSample ) {

  // let's play the selected waveforms at C3 (130.813 Hz)
  // for the duration of one Quarter Note at 120 BPM (500 ms)
  var frequency = 130.813;
  var noteDuration = 500;
  if( useEnvelope ) {

    if( recordSample ) {
      rec.record();
    }

    var noteOscillators = createAndPlayModulatorsForFrequency( frequency, 0 );
    if( noteOscillators["modulator"] ) {
      noteOscillators["modulator"].noteOn( frequency, audioContext.currentTime );
    }
    noteOscillators["carrier"].noteOn( frequency, audioContext.currentTime );

/*    window.setTimeout(function(){

      if( noteOscillators["modulator"] ) {
        noteOscillators["modulator"].noteOff( audioContext.currentTime );
        disconnectWaveOscillator( noteOscillators["modulator"] );
      }
      noteOscillators["carrier"].noteOff( audioContext.currentTime );
      disconnectWaveOscillator( noteOscillators["carrier"], recordSample );

    }, noteDuration);
    */

  } else {

    if( recordSample ) {
      rec.record();
    }

    var noteOscillators = createAndPlayModulatorsForFrequency( );


  /*  window.setTimeout(function(){

      if( recordSample ) {
        stopRecordingAndSave();
      }

      if( noteOscillators["modulator"] ) {
        noteOscillators["modulator"].oscillator.stop(0);
        noteOscillators["modulator"].oscillator.disconnect();
      }
      noteOscillators["carrier"].oscillator.stop(0);
      noteOscillators["carrier"].oscillator.disconnect();
    }, noteDuration);
    */

  }


}



/////////////////////////////////////////////
// A meter.
// when the javascript node is called
// we use information from the analyzer node
// to draw the volume
javascriptNode.onaudioprocess = function() {
    // console.log("meter");
    // get the average for the first channel
    var array =  new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(array);
    var average = getAverageVolume(array);

    // get the average for the second channel
    var array2 =  new Uint8Array(analyser2.frequencyBinCount);
    analyser2.getByteFrequencyData(array2);
    var average2 = getAverageVolume(array2);


    // clear the current state
    ctx.clearRect(0, 0, 80, 130);

    // set the fill style
    ctx.fillStyle=gradient;

    // create the meters
    ctx.fillRect(0,130-average,25,130);
    ctx.fillRect(30,130-average2,25,130);



    //////////////////////////////
    // frequency spectrum
    // clear the current state
    ctx2.clearRect(0, 0, 1000, 325);

    // set the fill style
    ctx2.fillStyle=gradient;

    drawSpectrum(array);

}

function getAverageVolume(array) {
    var values = 0;
    var average;

    var length = array.length;

    // get all the frequency amplitudes
    for (var i = 0; i < length; i++) {
        values += array[i];
    }

    average = values / length;
    return average;
}


var gradient = ctx.createLinearGradient(0,0,0,300);
function frequencySpectrum(){
    // create a gradient for the fill. Note the strange
    // offset, since the gradient is calculated based on
    // the canvas, not the specific element we draw
    gradient.addColorStop(1,'#000000');
    gradient.addColorStop(0.75,'#ff0000');
    gradient.addColorStop(0.25,'#ffff00');
    gradient.addColorStop(0,'#ffffff');

}
frequencySpectrum();

function drawSpectrum(array) {
        for ( var i = 0; i < (array.length); i++ ){
            var value = array[i];
            ctx2.fillRect(i*5,325-value,3,325);
            //  console.log([i,value])
            ctx2.globalAlpha = 0.2;
        }
};

















var useEnvelope = false;

var masterGain = audioContext.createGain();
masterGain.gain.value = 0.2;
masterGain.connect( audioContext.destination );

///////////////////////////////////////////////////
// sample recording
var rec = new Recorder( masterGain, {'workerPath': 'lib/recorderjs/recorderWorker.js'} );

function stopRecordingAndSave() {
  rec.stop();

  var baseFilename = "generation"+currentPopulationIndex+"-"+new Date().toISOString();
  rec.exportWAV(function(blob){
    Recorder.forceDownload( blob,
      baseFilename+".wav" );

    rec.clear();
  });

  // let's also save the CPPN this sample is based on
  saveCurrentCPPNToFile( baseFilename+".txt" );
}


function lerp( from, to, fraction ) {
  return from + fraction * ( to - from );
}

function displayCurrentGeneration() {
  $('h2').text( "Generation " + currentPopulationIndex );
}
